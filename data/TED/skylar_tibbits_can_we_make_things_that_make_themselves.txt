Talk	en	zh-tw
skylar_tibbits_can_we_make_things_that_make_themselves	Today I'd like to show you the future of the way we make things. I believe that soon our buildings and machines will be self-assembling, replicating and repairing themselves. So I'm going to show you what I believe is the current state of manufacturing, and then compare that to some natural systems. So in the current state of manufacturing, we have skyscrapers — two and a half years [of assembly time], 500,000 to a million parts, fairly complex, new, exciting technologies in steel, concrete, glass. We have exciting machines that can take us into space — five years [of assembly time], 2.5 million parts. But on the other side, if you look at the natural systems, we have proteins that have two million types, can fold in 10,000 nanoseconds, or DNA with three billion base pairs we can replicate in roughly an hour. So there's all of this complexity in our natural systems, but they're extremely efficient, far more efficient than anything we can build, far more complex than anything we can build. They're far more efficient in terms of energy. They hardly ever make mistakes. And they can repair themselves for longevity. So there's something super interesting about natural systems. And if we can translate that into our built environment, then there's some exciting potential for the way that we build things. And I think the key to that is self-assembly. So if we want to utilize self-assembly in our physical environment, I think there's four key factors. The first is that we need to decode all of the complexity of what we want to build — so our buildings and machines. And we need to decode that into simple sequences — basically the DNA of how our buildings work. Then we need programmable parts that can take that sequence and use that to fold up, or reconfigure. We need some energy that's going to allow that to activate, allow our parts to be able to fold up from the program. And we need some type of error correction redundancy to guarantee that we have successfully built what we want. So I'm going to show you a number of projects that my colleagues and I at MIT are working on to achieve this self-assembling future. The first two are the MacroBot and DeciBot. So these projects are large-scale reconfigurable robots — 8 ft., 12 ft. long proteins. They're embedded with mechanical electrical devices, sensors. You decode what you want to fold up into, into a sequence of angles — so negative 120, negative 120, 0, 0, 120, negative 120 — something like that; so a sequence of angles, or turns, and you send that sequence through the string. Each unit takes its message — so negative 120 — it rotates to that, checks if it got there and then passes it to its neighbor. So these are the brilliant scientists, engineers, designers that worked on this project. And I think it really brings to light: Is this really scalable? I mean, thousands of dollars, lots of man hours made to make this eight-foot robot. Can we really scale this up? Can we really embed robotics into every part? The next one questions that and looks at passive nature, or passively trying to have reconfiguration programmability. But it goes a step further, and it tries to have actual computation. It basically embeds the most fundamental building block of computing, the digital logic gate, directly into your parts. So this is a NAND gate. You have one tetrahedron which is the gate that's going to do your computing, and you have two input tetrahedrons. One of them is the input from the user, as you're building your bricks. The other one is from the previous brick that was placed. And then it gives you an output in 3D space. So what this means is that the user can start plugging in what they want the bricks to do. It computes on what it was doing before and what you said you wanted it to do. And now it starts moving in three-dimensional space — so up or down. So on the left-hand side, [1,1] input equals 0 output, which goes down. On the right-hand side, [0,0] input is a 1 output, which goes up. And so what that really means is that our structures now contain the blueprints of what we want to build. So they have all of the information embedded in them of what was constructed. So that means that we can have some form of self-replication. In this case I call it self-guided replication, because your structure contains the exact blueprints. If you have errors, you can replace a part. All the local information is embedded to tell you how to fix it. So you could have something that climbs along and reads it and can output at one to one. It's directly embedded; there's no external instructions. So the last project I'll show is called Biased Chains, and it's probably the most exciting example that we have right now of passive self-assembly systems. So it takes the reconfigurability and programmability and makes it a completely passive system. So basically you have a chain of elements. Each element is completely identical, and they're biased. So each chain, or each element, wants to turn right or left. So as you assemble the chain, you're basically programming it. You're telling each unit if it should turn right or left. So when you shake the chain, it then folds up into any configuration that you've programmed in — so in this case, a spiral, or in this case, two cubes next to each other. So you can basically program any three-dimensional shape — or one-dimensional, two-dimensional — up into this chain completely passively. So what does this tell us about the future? I think that it's telling us that there's new possibilities for self-assembly, replication, repair in our physical structures, our buildings, machines. There's new programmability in these parts. And from that you have new possibilities for computing. We'll have spatial computing. Imagine if our buildings, our bridges, machines, all of our bricks could actually compute. That's amazing parallel and distributed computing power, new design possibilities. So it's exciting potential for this. So I think these projects I've showed here are just a tiny step towards this future, if we implement these new technologies for a new self-assembling world. Thank you. (Applause)	今天，我想向你們展示我們未來製造東西的方式。我相信，我們的建築物和機器將很快便能自組，複製和修復自己。所以，我要告訴你，我相信是當前的製造業狀態，然後比較一些自然生態系統。 在當前的製造業狀態，我們有摩天大樓 —兩年半的時間,50萬至一百萬個部分組成，相當複雜，有令人振奮的新技術, 鋼鐵，水泥，玻璃。我們亦有令人振奮的機器，我們可以帶到太空 —250萬個部分。 但在另一方面，如果你看一下在自然生態系統，我們有兩百萬類型的蛋白質，可以在一萬納秒折叠，或DNA有30億個鹼基對，我們可以在大約一個小時複製。因此，雖然在我們這自然生態系統的複雜性，但它們效率非常高，遠遠超過任何我們可以建立的東西，遠遠超過任何我們可以建立複雜的高效。它們在能源方面更為有效。它們幾乎沒有犯錯誤。而且它們可以修復自己健康長壽。 因此，有一些自然生態系統是超級有趣。如果我們能夠將它轉化為我們的建築環境，那麼便會有一些令人興奮的潛力方式幫助我們建設東西。我認為關鍵是自我組裝。 因此，如果我們要利用我們的物理環境中的自組裝，我認為有四個關鍵因素。首先，我們需要我們所要建設的複雜性解碼—便是我們的建築物和機器。我們需要解碼成簡單的序列 —基本上是我們的建築物如何運作的DNA。然後，我們需要可編程的部分，可以利用該序列便使用來折疊起來，或重新配置。我們需要一些能源將允許激活，讓我們的部分可以折疊程序。我們需要某種類型的糾錯冗餘，以保證我們已經成功地構建我們所希望的西東。 所以我要告訴你一些項目，是我在麻省理工學院的同事和正在實現這種未來的自我組裝。第一兩個是MacroBot和DeciBot。因此，這些項目都是大型的可重構機器人 —8英尺，12英尺長的蛋白質。它們與機電設備，傳感器嵌入。你想要解碼什麼便折疊成什麼，成序列的角度 —負120，負120，0，0，120，負120 — 類似的東西，這樣的角度，或輪流順序，你便發送通過字符串序列。每個單位都需要它的消息 — 負120。它是旋轉​​的，檢查它是否到了那裡，然後把它傳遞給它的鄰居。 這些傑出的科學家，工程師，設計師，在這個項目上工作。我認為它真正在揭示：這是否真正的可擴展呢？我的意思是，數千美元，大量的工時，製造這8英尺的機器人。我們能否真正大規模跟進呢？我們能不能真正嵌入機器到每一個部分？下一個問題，以及著眼於被動性，或被動地試圖重新配置可編程。但它更進一步，嘗試以實際式計算。它基本上是最根本的計算，數字邏輯，直接嵌入到你的零件。 這是一個與非門。你有一個正四面體, 它是門，會做你的計算，和你有兩個可以輸入的正四面體。其中之一是來自用戶的輸入，像為你構建你的磚。另一種是從以前被放置的磚。然後它可以讓你在三維空間中的輸出。因此，這意味著用戶可以啟動他們想要做的磚堵。它計算它是之前做什麼，你說什麼，你想要它做的事情。現在它已經開始在三維空間中移動 —向上或向下。因此，在左側，[1,1]輸入等於輸出0，它便向下。在右側，[0,0]輸入1輸出，它便上升。這真正的意思是什麼，這是我們的結構現在正包含着我們所要建設的藍圖。 它們有所有的構建信息嵌入其中。因此，這意味著我們可以有某種形式的自我複製。在這種情況下，我把它稱為自導複製，因為你的結構包含着確切的藍圖。如果有錯誤，可以更換部件。所有局部嵌入的信息會告訴你如何解決它。所以，你可以擁有攀登的東西將它讀取，並且可以在一對一輸出。它直接嵌入; 沒有任何外部的指令。 我將展示的最後一個項目被稱為偏置鏈，它可能是我們現在被動自組裝系統最令人興奮的例子。它採取需要的可重構性和可編程性，並使它製造完全處於被動的系統。所以基本上你是有一個元素鏈。每個元素是完全相同的，而且它們偏倚。因此，每一條鏈，每個元素，可以拐左邊或右邊。所以當你組裝鏈，你基本上是在編程。你是在告訴每個單位是否應該向左或向右轉。所以，當你搖晃鏈，它便從然折疊成任何你編程的配置—在這種情況下，一個螺旋，或在這種情況下，兩個彼此相鄰的立方體。因此你基本上可以序程任何立體形狀 —一維，二維 — 完全被動地進入這條產業鏈。 這是告訴我們的未來是什麼呢？我認為，它告訴我們，在我們的物理結構，建築物有新的自組裝，複製，機器維修的可能性。在這些地區有新的可編程。並從這些你會有新的計算可能性。我們將會有空間的計算。試想一下，如果我們的建築物，橋樑，機器，我們所有的磚其實可以計算。這是驚人的並行和分佈式的計算能力，新的設計可能性。因此，這是一個令人興奮的潛力。所以，我覺得我已給你表明的，僅僅是對這個未來的一小步，如果我們能實施這些新技術創造一個新的自組裝世界。 謝謝。 (掌聲)
